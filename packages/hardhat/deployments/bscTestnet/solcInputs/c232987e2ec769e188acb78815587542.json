{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IApproveAndCall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IApproveAndCall {\n    enum ApprovalType {NOT_REQUIRED, MAX, MAX_MINUS_ONE, ZERO_THEN_MAX, ZERO_THEN_MAX_MINUS_ONE}\n\n    /// @dev Lens to be called off-chain to determine which (if any) of the relevant approval functions should be called\n    /// @param token The token to approve\n    /// @param amount The amount to approve\n    /// @return The required approval type\n    function getApprovalType(address token, uint256 amount) external returns (ApprovalType);\n\n    /// @notice Approves a token for the maximum possible amount\n    /// @param token The token to approve\n    function approveMax(address token) external payable;\n\n    /// @notice Approves a token for the maximum possible amount minus one\n    /// @param token The token to approve\n    function approveMaxMinusOne(address token) external payable;\n\n    /// @notice Approves a token for zero, then the maximum possible amount\n    /// @param token The token to approve\n    function approveZeroThenMax(address token) external payable;\n\n    /// @notice Approves a token for zero, then the maximum possible amount minus one\n    /// @param token The token to approve\n    function approveZeroThenMaxMinusOne(address token) external payable;\n\n    /// @notice Calls the position manager with arbitrary calldata\n    /// @param data Calldata to pass along to the position manager\n    /// @return result The result from the call\n    function callPositionManager(bytes memory data) external payable returns (bytes memory result);\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n    }\n\n    /// @notice Calls the position manager's mint function\n    /// @param params Calldata to pass along to the position manager\n    /// @return result The result from the call\n    function mint(MintParams calldata params) external payable returns (bytes memory result);\n\n    struct IncreaseLiquidityParams {\n        address token0;\n        address token1;\n        uint256 tokenId;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Calls the position manager's increaseLiquidity function\n    /// @param params Calldata to pass along to the position manager\n    /// @return result The result from the call\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (bytes memory result);\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IMulticallExtended.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol';\n\n/// @title MulticallExtended interface\n/// @notice Enables calling multiple methods in a single call to the contract with optional validation\ninterface IMulticallExtended is IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param deadline The time by which this function must be called before failing\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(uint256 deadline, bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param previousBlockhash The expected parent blockHash\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes32 previousBlockhash, bytes[] calldata data)\n        external\n        payable\n        returns (bytes[] memory results);\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/ISwapRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-periphery/contracts/interfaces/ISelfPermit.sol';\n\nimport './IV2SwapRouter.sol';\nimport './IV3SwapRouter.sol';\nimport './IApproveAndCall.sol';\nimport './IMulticallExtended.sol';\n\n/// @title Router token swapping functionality\ninterface ISwapRouter02 is IV2SwapRouter, IV3SwapRouter, IApproveAndCall, IMulticallExtended, ISelfPermit {\n\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IV2SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V2\ninterface IV2SwapRouter {\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param amountIn The amount of token to swap\n    /// @param amountOutMin The minimum amount of output that must be received\n    /// @param path The ordered list of tokens to swap through\n    /// @param to The recipient address\n    /// @return amountOut The amount of the received token\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Swaps as little as possible of one token for an exact amount of another token\n    /// @param amountOut The amount of token to swap for\n    /// @param amountInMax The maximum amount of input that the caller will pay\n    /// @param path The ordered list of tokens to swap through\n    /// @param to The recipient address\n    /// @return amountIn The amount of token to pay\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IV3SwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
    },
    "contracts/DcaExecutor.sol": {
      "content": "pragma solidity >=0.7.5;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ISwapRouter02} from \"@uniswap/swap-router-contracts/contracts/interfaces/ISwapRouter02.sol\";\nimport {IV3SwapRouter} from \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n\ncontract DcaExecutor {\n    struct DcaRequest {\n        address receiver;\n        IERC20 token1;\n        IERC20 token2;\n        uint256 token1InitialAmount;\n        uint256 token1CurrentAmount;\n        uint256 token2CurrentAmount;\n        ISwapRouter02 router;\n        uint256 swapExecutionPeriod;\n        uint256 startTimestamp;\n        uint256 numberOfSwapsToExecute;\n        uint256 numberOfSwapsExecuted;\n        uint256 lastExecutionTimestamp;\n    }\n\n    address[] public receivers;\n    mapping(address => uint256) public activeRequestsLength;\n    mapping(address => DcaRequest[]) public dcaRequests;\n    mapping(address => uint256) public completedRequestsLength;\n    mapping(address => DcaRequest[]) public dcaRequestsCompleted;\n\n\n    event Deposited(address indexed receiver, address token1Address, uint256 token1Amount, address token2Address, ISwapRouter02 router, uint256 swapExecutionPeriod, uint256 swapStartTime, uint256 numberOfSwaps);\n    event Swapped(address indexed receiver, address token1Address, uint256 token1Amount, address token2Address, uint256 token2Amount);\n    event Cancelled(address indexed receiver, uint256 index);\n    event Completed(address indexed receiver, uint256 index);\n\n    function submitDcaRequest(\n        IERC20 token1,\n        IERC20 token2,\n        uint256 token1Amount,\n        ISwapRouter02 router,\n        uint256 numberOfSwaps,\n        uint256 swapExecutionPeriod,\n        uint256 startTimestamp\n    ) external {\n        require(token1.transferFrom(msg.sender, address(this), token1Amount), \"funding transfer failed\");\n        receivers.push(msg.sender);\n        dcaRequests[msg.sender].push(\n            DcaRequest(\n                {\n                    receiver: msg.sender,\n                    token1: token1,\n                    token2: token2,\n                    token1InitialAmount: token1Amount,\n                    token1CurrentAmount: token1Amount,\n                    token2CurrentAmount: 0,\n                    router: router,\n                    swapExecutionPeriod: swapExecutionPeriod,\n                    startTimestamp: startTimestamp,\n                    numberOfSwapsToExecute: numberOfSwaps,\n                    numberOfSwapsExecuted: 0,\n                    lastExecutionTimestamp: 0\n                }\n            )\n        );\n        token1.approve(address(router), token1Amount);\n        // check if token1 is available for lending on a lending protocol of choice\n        // submit available amount of token1 to a lending protocol to earn interest\n        activeRequestsLength[msg.sender]++;\n        emit Deposited(msg.sender, address(token1), token1Amount, address(token2), router, swapExecutionPeriod, startTimestamp, numberOfSwaps);\n    }\n\n    function executeSwap(address receiver, uint256 index) external {\n        DcaRequest memory request = dcaRequests[receiver][index];\n        require(block.timestamp >= request.startTimestamp, \"start date not reached\");\n        require(request.numberOfSwapsToExecute > 0, \"no more swaps\");\n        require(block.timestamp >= request.lastExecutionTimestamp + request.swapExecutionPeriod, \"swap execution period not reached\");\n\n        uint256 amountIn = request.token1CurrentAmount / request.numberOfSwapsToExecute;\n        // withdraw `amountIn` amount of token1 from lending protocol to perform swap\n        IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter\n            .ExactInputSingleParams({\n                tokenIn: address(request.token1),\n                tokenOut: address(request.token2),\n                fee: 3000,\n                recipient: address(this),\n                amountIn: amountIn,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n\n        uint256 amountOut = request.router.exactInputSingle(params);\n        // check if token2 is available for lending on a lending protocol of choice\n        // deposit `amountOut` amount of token2 to lending protocol to earn interest\n        request.numberOfSwapsToExecute--;\n        request.numberOfSwapsExecuted++;\n        request.token1CurrentAmount -= amountIn;\n        request.token2CurrentAmount += amountOut;\n        request.lastExecutionTimestamp = block.timestamp;\n        dcaRequests[receiver][index] = request;\n        emit Swapped(receiver, address(request.token1), amountIn, address(request.token2), amountOut);\n\n        if (request.numberOfSwapsToExecute == 0) {\n            _completeRequest(receiver, index);\n            emit Completed(receiver, dcaRequestsCompleted[receiver].length - 1);\n        }\n    }\n\n    function cancelDcaRequest(address receiver, uint256 index) external {\n        require(receiver == msg.sender, \"not authorized\");\n        _completeRequest(receiver, index);\n        emit Cancelled(receiver, dcaRequestsCompleted[receiver].length - 1);\n    }\n\n    function _completeRequest(address receiver, uint256 index) private {\n        // withdraw all token1 and token2 from lending protocol\n        DcaRequest memory request = dcaRequests[receiver][index];\n        require(request.token1.transfer(receiver, request.token1CurrentAmount), \"transfer failed\");\n        require(request.token2.transfer(receiver, request.token2CurrentAmount), \"transfer failed\");\n        dcaRequestsCompleted[receiver].push(request);\n        dcaRequests[receiver][index] = dcaRequests[receiver][dcaRequests[receiver].length - 1];\n        dcaRequests[receiver].pop();\n        activeRequestsLength[receiver] = dcaRequests[receiver].length;\n        completedRequestsLength[receiver] = dcaRequestsCompleted[receiver].length;\n    }\n\n    // add function to withdraw earned interest to the user's wallet\n}\n"
    },
    "contracts/DcaExecutorV2.sol": {
      "content": "pragma solidity >=0.7.5;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\ncontract DcaExecutor {\n    struct DcaRequest {\n        address receiver;\n        IERC20 token1;\n        IERC20 token2;\n        uint256 token1InitialAmount;\n        uint256 token1CurrentAmount;\n        uint256 token2CurrentAmount;\n        IUniswapV2Router02 router;\n        uint256 swapExecutionPeriod;\n        uint256 startTimestamp;\n        uint256 numberOfSwapsToExecute;\n        uint256 numberOfSwapsExecuted;\n        uint256 lastExecutionTimestamp;\n    }\n\n    address[] public receivers;\n    mapping(address => uint256) public activeRequestsLength;\n    mapping(address => DcaRequest[]) public dcaRequests;\n    mapping(address => uint256) public completedRequestsLength;\n    mapping(address => DcaRequest[]) public dcaRequestsCompleted;\n\n    event Deposited(address indexed receiver, address token1Address, uint256 token1Amount, address token2Address, IUniswapV2Router02 router, uint256 swapExecutionPeriod, uint256 swapStartTime, uint256 numberOfSwaps);\n    event Swapped(address indexed receiver, address token1Address, uint256 token1Amount, address token2Address, uint256 token2Amount);\n    event Cancelled(address indexed receiver, uint256 index);\n    event Completed(address indexed receiver, uint256 index);\n\n    // approve the contract to spend the token\n    function submitDcaRequest(\n        IERC20 token1,\n        IERC20 token2,\n        uint256 token1Amount,\n        IUniswapV2Router02 router,\n        uint256 numberOfSwaps,\n        uint256 swapExecutionPeriod,\n        uint256 startTimestamp\n    ) external {\n        require(token1.transferFrom(msg.sender, address(this), token1Amount), \"funding transfer failed\");\n        receivers.push(msg.sender);\n        dcaRequests[msg.sender].push(\n            DcaRequest(\n                {\n                    receiver: msg.sender,\n                    token1: token1,\n                    token2: token2,\n                    token1InitialAmount: token1Amount,\n                    token1CurrentAmount: token1Amount,\n                    token2CurrentAmount: 0,\n                    router: router,\n                    swapExecutionPeriod: swapExecutionPeriod,\n                    startTimestamp: startTimestamp,\n                    numberOfSwapsToExecute: numberOfSwaps,\n                    numberOfSwapsExecuted: 0,\n                    lastExecutionTimestamp: 0\n                }\n            )\n        );\n        activeRequestsLength[msg.sender] = dcaRequests[msg.sender].length;\n        token1.approve(address(router), token1Amount);\n        emit Deposited(msg.sender, address(token1), token1Amount, address(token2), router, swapExecutionPeriod, startTimestamp, numberOfSwaps);\n    }\n\n    function executeSwap(address receiver, uint256 index) external {\n        address[] memory path;\n        DcaRequest memory request = dcaRequests[receiver][index];\n        require(block.timestamp >= request.startTimestamp, \"start date not reached\");\n        require(request.numberOfSwapsToExecute > 0, \"no more swaps\");\n        require(block.timestamp >= request.lastExecutionTimestamp + request.swapExecutionPeriod, \"swap execution period not reached\");\n\n        uint256 amountIn = request.token1CurrentAmount / request.numberOfSwapsToExecute;\n        path[0] = address(request.token1);\n        path[1] = address(request.token2);\n        uint256[] memory amounts = request.router.swapExactTokensForTokens({\n                amountIn: amountIn,\n                amountOutMin: 0,\n                path: path,\n                to: receiver,\n                deadline: block.number + 10\n            });\n        request.numberOfSwapsToExecute--;\n        request.numberOfSwapsExecuted++;\n        request.token1CurrentAmount -= amountIn;\n        request.token2CurrentAmount += amounts[1];\n        request.lastExecutionTimestamp = block.timestamp;\n        dcaRequests[receiver][index] = request;\n        emit Swapped(receiver, address(request.token1), amountIn, address(request.token2), amounts[0]);\n\n        if (request.numberOfSwapsToExecute == 0) {\n            _completeRequest(receiver, index);\n            emit Completed(receiver, dcaRequestsCompleted[receiver].length - 1);\n        }\n    }\n\n    function cancelDcaRequest(address receiver, uint256 index) external {\n        require(receiver == msg.sender, \"not authorized\");\n        _completeRequest(receiver, index);\n        emit Cancelled(receiver, dcaRequestsCompleted[receiver].length - 1);\n    }\n\n    function _completeRequest(address receiver, uint256 index) private {\n        DcaRequest memory request = dcaRequests[receiver][index];\n        require(request.token1.transfer(receiver, request.token1CurrentAmount), \"transfer failed\");\n        require(request.token2.transfer(receiver, request.token2CurrentAmount), \"transfer failed\");\n        dcaRequestsCompleted[receiver].push(request);\n        dcaRequests[receiver][index] = dcaRequests[receiver][dcaRequests[receiver].length - 1];\n        dcaRequests[receiver].pop();\n        activeRequestsLength[receiver] = dcaRequests[receiver].length;\n        completedRequestsLength[receiver] = dcaRequestsCompleted[receiver].length;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}